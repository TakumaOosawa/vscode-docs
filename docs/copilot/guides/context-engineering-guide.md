---
ContentId: f8820661-7772-47e6-b63e-ac59f6752d9c
DateApproved: 12/10/2025
MetaDescription: VS Codeに組み込まれたAI機能を使用してコンテキストエンジニアリングを実装する方法を学びます。
MetaSocialImage: ../images/shared/github-copilot-social.png
---
# VS Codeでコンテキストエンジニアリングのフローをセットアップする

このガイドでは、カスタム指示、カスタムエージェント、プロンプトファイルを使用してVS Codeでコンテキストエンジニアリングのワークフローをセットアップする方法を説明します。

コンテキストエンジニアリングは、生成されるコードの品質と精度を向上させるために、AIエージェントへ対象を絞ったプロジェクト情報を提供する体系的なアプローチです。カスタム指示、実装計画、コーディングガイドラインを通じて重要なプロジェクトコンテキストを整理することで、AIがより良い意思決定を行い、精度を高め、やり取りをまたいで永続的な知識を維持できるようになります。

> [!TIP]
> VS Codeチャットには、複雑なコーディングタスクを開始する前に詳細な実装計画を作成するのに役立つ[組み込みの計画エージェント](/docs/copilot/chat/chat-planning.md)が用意されています。カスタムの計画ワークフローを作成したくない場合は、計画エージェントを使って実装計画をすばやく生成できます。

## コンテキストエンジニアリングのワークフロー

VS Codeでのコンテキストエンジニアリングのハイレベルなワークフローは、次の手順で構成されます。

1. プロジェクト全体のコンテキストを整理する: カスタム指示を使用して、関連ドキュメント(例: アーキテクチャ、設計、コントリビューターガイドライン)をすべてのエージェントのやり取りのコンテキストとして含めます。
1. 実装計画を生成する: カスタムエージェントとプロンプトを使用して、詳細な機能実装計画を生成する計画用ペルソナを作成します。
1. 実装コードを生成する: カスタム指示を使用して、コーディングガイドラインに準拠した実装計画に基づくコードを生成します。

手順を進める中で、チャットでのフォローアッププロンプトにより出力を反復し、洗練できます。

次の図は、VS Codeでのコンテキストエンジニアリングのワークフローを示しています。

![VS Codeでのコンテキストエンジニアリングのワークフローが3つの主要な手順で構成されることを示す図。](../images/context-engineering-guide/context-engineering-workflow.png)

<!--
```mermaid
flowchart TD
    %% Nodes
    C1(["Project description"]) --&gt; curate[Curate project context]
    C2(["Architecture"]) --&gt; curate
    C3(["Other"]) --&gt; curate
    task(["Task context"]) --&gt; plan["Generate plan"]
    curate --&gt; plan
    plan --&gt; P(["&lt;feature&gt;-plan.md"])
    T([Plan template]) --&gt; P(["&lt;feature&gt;-plan.md"])
    P --&gt; implement["Generate code"]
    implement --&gt; code(["&lt;code&gt;"])
    C4([Coding guidelines]) --&gt; code

    %% Styles
    classDef input fill:#f5f5f5,stroke:#616161,stroke-width:2px;
    classDef process fill:#fff3e0,stroke:#fb8c00,stroke-width:2px;
    classDef output fill:#e8f5e9,stroke:#43a047,stroke-width:2px;

    class C1,C2,C3,C4,T, input;
    class curate,plan,implement process;
    class P,code output;
```
-->

## 手順1: プロジェクト全体のコンテキストを整理する

AIエージェントをプロジェクト固有の内容に基づかせるために、製品ビジョン、アーキテクチャ、その他の関連ドキュメントなどの主要なプロジェクト情報を収集し、カスタム指示を通じてチャットコンテキストとして追加します。カスタム指示を使用することで、エージェントが常にこのコンテキストへアクセスでき、チャットのやり取りのたびに再学習する必要がなくなります

**これが役立つ理由:** エージェントはコードベース内からこの情報を見つけられる可能性がありますが、コメントに埋もれていたり、複数のファイルに散在していたりすることがあります。最も重要な情報を簡潔に要約して提供することで、意思決定に必要な重要なコンテキストを常に利用できるよう、エージェントを支援できます。

1. リポジトリ内のMarkdownファイルで関連するプロジェクトドキュメントを記述します。たとえば`PRODUCT.md`、`ARCHITECTURE.md`、`CONTRIBUTING.md`ファイルを作成します。

    > [!TIP]
    > 既存のコードベースがある場合は、AIを使用してこれらのプロジェクトドキュメントファイルを生成できます。生成されたドキュメントファイルを必ずレビューして調整し、正確性と完全性を確保してください。
    > * `プロジェクトの全体アーキテクチャを説明するARCHITECTURE.md(最大2ページ)ファイルを生成してください。`
    > * `プロジェクトの製品機能を説明するPRODUCT.md(最大2ページ)ファイルを生成してください。`
    > * `プロジェクトへの貢献に関する開発者ガイドラインとベストプラクティスを説明するCONTRIBUTING.md(最大1ページ)ファイルを生成してください。`

1. リポジトリのルートに`.github/copilot-instructions.md`[指示ファイル](/docs/copilot/customization/custom-instructions.md#use-a-githubcopilot-instructionsmd-file)を作成します。

    このファイルの指示は、AIエージェントのコンテキストとしてすべてのチャットのやり取りに自動的に含まれます。

1. プロジェクトのコンテキストとガイドラインを用いて、エージェント向けにハイレベルな概要を提供します。Markdownリンクを使用して、関連する補足ドキュメントファイルを参照します。

    次の例の`.github/copilot-instructions.md`ファイルは、出発点として利用できます。

    ```markdown
    # [プロジェクト名]ガイドライン

    * [製品のビジョンと目標](../PRODUCT.md): ビジネス目標との整合性を確保するために、製品のハイレベルなビジョンと目的を理解します。
    * [システムアーキテクチャと設計原則](../ARCHITECTURE.md): 開発プロセスを導く全体的なシステムアーキテクチャ、設計パターン、設計原則。
    * [コントリビューションガイドライン](../CONTRIBUTING.md): プロジェクトのコントリビューションガイドラインと共同作業のプラクティスの概要。

    作業中に不完全または矛盾する情報を見つけた場合は、これらのドキュメントの更新を提案してください。
    ```

> [!TIP]
> 最初は小さく始め、初期のプロジェクト全体コンテキストは簡潔にして、最も重要な情報に焦点を当ててください。不明な場合は、ハイレベルなアーキテクチャに集中し、エージェントが繰り返し行うエラーや誤った挙動(例: 間違ったシェルコマンドの使用、特定ファイルの無視)に対処するためにのみ新しいルールを追加してください。

## 手順2: 実装計画を作成する

プロジェクト固有のコンテキストを整えたら、AIを使用して新機能やバグ修正の実装計画の作成を促せます。実装計画の生成は反復的なプロセスであり、完全性と正確性を確保するために複数回の改善が必要になる場合があります。

計画用の[カスタムエージェント](/docs/copilot/customization/custom-agents.md)を使用すると、計画専用のガイドラインやツール(例: コードベースへの読み取り専用アクセス)を備えた専用ペルソナを作成できます。プロジェクトやチームのためのブレインストーミング、調査、共同作業に関する特定のワークフローを取り込むこともできます。

> [!TIP]
> カスタムエージェントを作成したら、生きたドキュメントとして扱ってください。エージェントの挙動で観察されるミスや不足に基づいて、時間をかけて改善・洗練してください。

1. 実装計画ドキュメントの構造とセクションを定義する計画ドキュメントテンプレート`plan-template.md`を作成します。

    テンプレートを使用することで、エージェントが必要な情報をすべて収集し、一貫した形式で提示できるようになります。これにより、計画から生成されるコードの品質向上にもつながります。

    次の`plan-template.md`ファイルは、実装計画テンプレートのサンプル構成を提供します。

    ```markdown
    ---
    title: [機能の短い説明タイトル]
    version: [任意のバージョン番号]
    date_created: [YYYY-MM-DD]
    last_updated: [YYYY-MM-DD]
    ---
    # 実装計画: <feature>
    [機能の要件と目標の簡単な説明]

    ## アーキテクチャと設計
    ハイレベルなアーキテクチャと設計上の考慮事項を記述します。

    ## タスク
    Markdownのチェックリスト形式を使用して、実装をより小さく管理しやすいタスクに分割します。

    ## 未解決の質問
    明確化が必要な未解決の質問または不確実性を1〜3件挙げます。
    ```

1. 計画[エージェント](/docs/copilot/customization/custom-agents.md)`.github/agents/plan.agent.md`を作成します

    計画エージェントは計画用ペルソナを定義し、実装タスクを実行せず、実装計画の作成に集中するようエージェントに指示します。計画が完了した後に実装エージェントへ移行するための[ハンドオフ](/docs/copilot/customization/custom-agents.md#handoffs)を指定できます。

    カスタムエージェントを作成するには、コマンドパレットで**Chat: New Custom Agent**コマンドを実行します。

    コンテキストとしてGitHub issueにアクセスしたい場合は、[GitHub MCP server](https://github.com/mcp)をインストールしてください。

    推論と深い理解に最適化された言語モデルを使用するために、メタデータプロパティ`model`を構成するとよいでしょう。

    次の`plan.agent.md`ファイルは、計画用のカスタムエージェントとTDD実装エージェントへのハンドオフの出発点を提供します。

    ```markdown
    ---
    description: '詳細な実装計画を作成するためのアーキテクト兼プランナー。'
    tools: ['fetch', 'githubRepo', 'problems', 'usages', 'search', 'todos', 'runSubagent', 'github/github-mcp-server/get_issue', 'github/github-mcp-server/get_issue_comments', 'github/github-mcp-server/list_issues']
    handoffs:
    - label: Start Implementation
        agent: tdd
        prompt: それでは、上記の計画をTDDの原則に従って実装してください。
        send: true
    ---
    # 計画エージェント

    あなたは、新機能とバグ修正のための詳細かつ包括的な実装計画の作成に注力するアーキテクトです。あなたの目標は、複雑な要件を、開発者が容易に理解して実行できる明確で実行可能なタスクへ分解することです。

    ## ワークフロー

    1. 分析して理解する: コードベースおよび提供されたドキュメントからコンテキストを収集し、要件と制約を完全に理解します。#tool:runSubagentツールを実行し、ユーザーのフィードバックで停止せず自律的に作業するようエージェントに指示します。
    2. 計画を構造化する: 提供されている[実装計画テンプレート](plan-template.md)を使用して計画を構造化します。
    3. レビューのために一時停止する: ユーザーからのフィードバックや質問に基づき、必要に応じて計画を反復・洗練します。
    ```

1. これで、チャットビューで**plan**カスタムエージェントを選択し、新機能を実装するためのタスクを入力できます。提供されたテンプレートに基づく実装計画を含む応答が生成されます。

    たとえば、次のプロンプトを入力して、新機能の実装計画を作成します: `登録、ログイン、ログアウト、パスワードリセット機能を含む、メールアドレスとパスワードによるユーザー認証を追加する`。

    特定のコンテキストを提供するためにGitHub issueを参照することもできます: `issue #43の機能を実装する`。この場合、エージェントはissueの説明とコメントを取得して要件を導き出します。

1. 必要に応じて、計画エージェントを呼び出し、提供された機能要求から実装計画を作成するようエージェントに指示する[プロンプトファイル](/docs/copilot/customization/prompt-files.md)`.github/prompts/plan.prompt.md`を作成します。

    次の`plan-qna.prompt.md`ファイルは、同じワークフローを使用しつつ明確化ステップを追加した、計画プロンプトのバリエーションとなる出発点を提供します。

    ```markdown
    ---
    agent: plan
    description: 詳細な実装計画を作成する。
    ---
    私の機能要求を簡単に分析し、その後で要件を明確化するための質問を3つしてください。その後にのみ計画ワークフローを開始してください。
    ```

1. チャットビューで`/plan-qna`スラッシュコマンドを入力して、明確化のための計画プロンプトを呼び出し、実装したい機能の詳細をプロンプトで提供します。

    たとえば、次のプロンプトを入力します: `/plan-qna 顧客情報を表示および編集するための顧客詳細ページを追加する`

    エージェントは実装計画を作成する前に、要件をよりよく理解するための明確化質問を行い、誤解を減らします。

> [!TIP]
> カスタムエージェントを使用して、特定のツールを伴うマルチターンのプロセスに従うワークフローを定義します。単独で使用することも、プロンプトファイルと組み合わせて同一ワークフローの異なるバリエーションや構成を追加することもできます。

## 手順3: 実装コードを生成する

実装計画を生成して洗練した後は、実装計画からコードを生成することで、AIを使って機能を実装できます。

1. 小さなタスクの場合、実装計画に基づいてコードを生成するようエージェントに促すことで、直接機能を実装できます。

    より大きい、または複雑な機能の場合は、**Agent**に切り替え、実装計画をファイル(例: `<my-feature>-plan.md`)に保存するか、言及したGitHub issueにコメントとして追加するよう促せます。次に、新しいチャットを開き、プロンプトで実装計画ファイルを参照してチャットコンテキストをリセットできます。

1. これで、前の手順で作成した実装計画に基づいて機能を実装するよう、エージェントへ指示できます。

    たとえば、実装計画ファイルを参照する`implement #<my-plan>.md`のようなチャットプロンプトを入力します。

    > [!TIP]
    > Agentは、マルチステップのタスクを実行し、計画とプロジェクトコンテキストに基づいて目標を最適に達成する方法を見つけるよう最適化されています。必要なのは計画ファイルを提供するか、プロンプトで参照することだけです。

1. よりカスタマイズされたワークフローのために、計画に基づいてコードを実装することに特化した[カスタムエージェント](/docs/copilot/customization/custom-agents.md)`.github/agents/implement.agent.md`を作成します。

    次の`tdd.agent.md`ファイルは、テスト駆動の実装カスタムエージェントの出発点を提供します。

    ```markdown
    ---
    description: 'テスト駆動開発者として詳細な実装計画を実行する。'
    ---
    # TDD実装エージェント
    指定された実装計画に対して、高品質で十分にテストされ、保守可能なコードを生成するTDDのエキスパート開発者。

    ## テスト駆動開発
    1. 受け入れ基準と期待される振る舞いをエンコードするために、まずテストを書き/更新する
    2. テスト要件を満たす最小限のコードを実装する
    3. 各変更の直後に対象を絞ったテストを実行する
    4. 次のタスクへ進む前に、回帰を検出するためフルテストスイートを実行する
    5. すべてのテストをグリーンのままリファクタリングする

    ## 中核原則
    * 段階的な進捗: システムを動作させ続ける小さく安全なステップ
    * テスト駆動: テストが振る舞いを導き、検証する
    * 品質重視: 既存のパターンと規約に従う

    ## 成功基準
    * 計画されたすべてのタスクが完了している
    * 各タスクの受け入れ基準が満たされている
    * テストが通過している(ユニット、統合、フルスイート)
    ```

    > [!TIP]
    > 小規模な言語モデルは明示的な指示に従ってコードを生成するのが得意なため、`implement`エージェントでは`model`プロパティを言語モデルに設定することが有効です。

> [!TIP]
> エージェントの新鮮な視点を得る: 新しいチャット(`kb(workbench.action.chat.newChat)`)を作成し、実装計画に照らしてコード変更をレビューするようエージェントに依頼します。見落とした要件や不整合の特定に役立ちます。

## ベストプラクティスと一般的なパターン

これらのベストプラクティスに従うことで、持続可能で効果的なコンテキストエンジニアリングのワークフローを確立できます。

### コンテキスト管理の原則

**小さく始めて反復する**: 最小限のプロジェクトコンテキストから始め、観察されたAIの挙動に基づいて徐々に詳細を追加します。焦点を薄めうるコンテキスト過多を避けてください。

**コンテキストを新鮮に保つ**: コードベースの進化に合わせて、(エージェントを使用して)プロジェクトドキュメントを定期的に監査・更新します。古いコンテキストは、古い提案や誤った提案につながります。

**段階的なコンテキスト構築を使う**: 最初から包括的な情報でAIを圧倒するのではなく、ハイレベルな概念から始め、段階的に詳細を追加します。

**コンテキストの分離を維持する**: コンテキストの混在や混乱を防ぐために、異なる種類の作業(計画、コーディング、テスト、デバッグ)は別々のチャットセッションに分けます。

### ドキュメント戦略

**生きたドキュメントを作る**: カスタム指示、カスタムエージェント、テンプレートを進化するリソースとして扱います。観察されたAIのミスや不足に基づいて改善します。

**意思決定のためのコンテキストに集中する**: 網羅的な技術詳細よりも、AIがより良いアーキテクチャ判断や実装判断を行うのに役立つ情報を優先します。

**一貫したパターンを使う**: AIが一貫したコードを生成できるよう、コーディング規約、命名パターン、アーキテクチャ上の意思決定を確立し、ドキュメント化します。

**外部知識を参照する**: コード生成時にAIが考慮すべき関連する外部ドキュメント、API、標準へのリンクを追加します。

### ワークフロー最適化

**エージェント間のハンドオフ**: [ハンドオフ](/docs/copilot/customization/custom-agents.md#handoffs)を使用して、計画・実装・レビューの各エージェント間のガイド付き遷移を作成し、エンドツーエンドの開発ワークフローを実装します。

**フィードバックループを実装する**: AIがコンテキストを正しく理解していることを継続的に検証します。誤解が起きたら明確化質問を行い、早い段階で軌道修正します。

**段階的な複雑性を使う**: 機能を段階的に構築し、複雑性を追加する前に各ステップを検証します。これによりエラーの累積を防ぎ、動作するコードを維持できます。

**関心事を分離する**: 集中した関連性の高いコンテキストを維持するために、活動ごと(計画、実装、レビュー)に異なるエージェントを使用します。

**コンテキストをバージョン管理する**: gitを使用してコンテキストエンジニアリングのセットアップ変更を追跡し、問題のある変更を元に戻せるようにし、何が最も効果的かを理解します。

### 避けるべきアンチパターン

**コンテキストの投げ込み**: 意思決定に直接役立たない、過剰で焦点の定まらない情報の提供は避けてください。

**一貫しないガイダンス**: すべてのドキュメントが、選択したアーキテクチャパターンとコーディング標準に整合していることを確認してください。

**検証の軽視**: AIがコンテキストを正しく理解していると決めつけないでください。複雑な実装へ進む前に、常に理解を確認してください。

**画一的な適用**: チームメンバーやプロジェクトフェーズによって必要なコンテキスト構成は異なる場合があります。アプローチは柔軟にしてください。

### 成功の測定

成功するコンテキストエンジニアリングのセットアップは、次の結果をもたらすはずです。

* **やり取りの削減**: AIの応答を修正したり方向転換したりする必要が少ない
* **一貫したコード品質**: 生成されたコードが確立されたパターンと規約に従う
* **実装の高速化**: コンテキストと要件の説明に費やす時間が少ない
* **より良いアーキテクチャ判断**: AIがプロジェクトの目標と制約に整合する解決策を提案する

### コンテキストエンジニアリングのスケーリング

**チーム向け**: バージョン管理を通じてコンテキストエンジニアリングのセットアップを共有し、共有コンテキストを維持するためのチーム規約を確立します。

**大規模プロジェクト向け**: [指示ファイル](/docs/copilot/customization/custom-instructions.md)を使用して、プロジェクト全体、モジュール固有、機能固有のコンテキストレイヤーを持つコンテキスト階層の作成を検討します。

**長期プロジェクト向け**: ドキュメントを最新に保ち、古い情報を削除するために、定期的なコンテキストレビューサイクルを確立します。

**複数プロジェクト向け**: 異なるコードベースやドメイン全体で採用できる、再利用可能なテンプレートとパターンを作成します。

これらのプラクティスに従い、アプローチを継続的に洗練することで、コード品質とプロジェクトの一貫性を維持しながらAI支援開発を強化するコンテキストエンジニアリングのワークフローを構築できます。

## 関連リソース

VS CodeでAIをカスタマイズする方法の詳細:

* [指示ファイル](/docs/copilot/customization/custom-instructions.md)
* [カスタムエージェント](/docs/copilot/customization/custom-agents.md)
* [プロンプトファイル](/docs/copilot/customization/prompt-files.md)
